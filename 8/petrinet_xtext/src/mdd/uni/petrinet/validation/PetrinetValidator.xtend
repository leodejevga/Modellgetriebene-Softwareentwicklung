/*
 * generated by Xtext 2.12.0
 */
package mdd.uni.petrinet.validation

import mdd.uni.petrinet.petrinet.Arc
import mdd.uni.petrinet.petrinet.PTArc
import mdd.uni.petrinet.petrinet.Petrinet
import mdd.uni.petrinet.petrinet.PetrinetPackage
import mdd.uni.petrinet.petrinet.TPArc
import mdd.uni.petrinet.petrinet.Transition
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PetrinetValidator extends AbstractPetrinetValidator {
	
	public static val TRANS_MISSING_IN = 'transition missing incoming edge'
	public static val TRANS_MISSING_OUT = 'transition missing outgoing edge'
	public static val TRANS_MISSING_EDGE_NOFIX = 'transition missing incoming edge (no fix)'
	public static val DUPLICATE_EDGES = 'duplicate edges'
	public static val ARC_REFERENCE_MISSING = 'arc not referenced'
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					PetrinetPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	
	@Check
	def transitionMissingIn(Transition trans) {
		if (trans.in.size == 0) {
			val petrinet = trans.eContainer as Petrinet
			if (petrinet.places !== null && petrinet.places.size > 0 && petrinet.arcs !== null) {
				warning('Transition does not have incoming edges',
					PetrinetPackage.Literals.TRANSITION__NAME,
					TRANS_MISSING_IN, 
					trans.name
				)
			} else {
				warning('Transition does not have incoming edges (no fix available)',
					PetrinetPackage.Literals.TRANSITION__NAME,
					TRANS_MISSING_EDGE_NOFIX
				)
			}
		} 
	}
	
	@Check
	def transitionMissingOut(Transition trans) {
		if (trans.out.size == 0) {
			val petrinet = trans.eContainer as Petrinet
			if (petrinet.places !== null && petrinet.places.size > 0 && petrinet.arcs !== null) {
				warning('Transition does not have outgoing edges',
					PetrinetPackage.Literals.TRANSITION__NAME,
					TRANS_MISSING_OUT, 
					trans.name
			)
			} else {
				warning('Transition does not have outgoing edges (no fix available)',
					PetrinetPackage.Literals.TRANSITION__NAME,
					TRANS_MISSING_EDGE_NOFIX
				)
			}
		} 
	}
	
	@Check
	def duplicateEdges(Arc arc) {
		var duplicates = emptyList
		val petrinet = (arc.eContainer as Petrinet)
		if (arc instanceof PTArc) {
			val PTArc ptarc = arc as PTArc
			if (ptarc.source !== null && ptarc.target !== null) {
				duplicates = petrinet.arcs.filter [ a |
					a !== ptarc
					&& a instanceof PTArc 
					&& (a as PTArc).source === ptarc.source 
					&& (a as PTArc).target === ptarc.target
				].toList				
			}
		}

		if (arc instanceof TPArc) {
			val TPArc tparc = arc as TPArc
			if (tparc.source !== null && tparc.target !== null) {
				duplicates = petrinet.arcs.filter [ a |
					a !== tparc
					&& a instanceof TPArc
					&& (a as TPArc).source === tparc.source 
					&& (a as TPArc).target === tparc.target
				].toList
			}
		}
		
		if (!duplicates.empty) {
			error(
				"Duplicate edges found",
				PetrinetPackage.Literals.ARC__NAME,
				DUPLICATE_EDGES,
				arc.name
			)
		}
	}
	
	@Check
	def arcNotReferencedCorrectly(Arc arc) {
		var raise = false
		if (arc instanceof PTArc) {
			val ptarc = arc as PTArc
			if (!ptarc.source.out.contains(ptarc) 
				|| !ptarc.target.in.contains(ptarc)) {
				raise = true
			}
		} else if (arc instanceof TPArc) {
			val tparc = arc as TPArc
			if (!tparc.source.out.contains(tparc) 
				|| !tparc.target.in.contains(tparc)) {
				raise = true
			}
		}
		
		if (raise) {
			error(
				"Arc not referenced correctly",
				PetrinetPackage.Literals.ARC__NAME,
				ARC_REFERENCE_MISSING,
				arc.name
			)
		}
	}
}
