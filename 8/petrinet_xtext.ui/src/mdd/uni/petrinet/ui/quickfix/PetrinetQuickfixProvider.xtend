/*
 * generated by Xtext 2.12.0
 */
package mdd.uni.petrinet.ui.quickfix

import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import mdd.uni.petrinet.validation.PetrinetValidator
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import org.eclipse.xtext.ui.editor.model.edit.ISemanticModification
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext
import mdd.uni.petrinet.petrinet.Transition
import mdd.uni.petrinet.petrinet.PetrinetFactory
import mdd.uni.petrinet.petrinet.Petrinet
import mdd.uni.petrinet.petrinet.PTArc
import mdd.uni.petrinet.petrinet.TPArc
import java.util.Collection
import java.util.List
import mdd.uni.petrinet.petrinet.Arc

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
class PetrinetQuickfixProvider extends DefaultQuickfixProvider {
	
	var private List<Arc> duplicates = emptyList 

//	@Fix(PetrinetValidator.INVALID_NAME)
//	def capitalizeName(Issue issue, IssueResolutionAcceptor acceptor) {
//		acceptor.accept(issue, 'Capitalize name', 'Capitalize the name.', 'upcase.png') [
//			context |
//			val xtextDocument = context.xtextDocument
//			val firstLetter = xtextDocument.get(issue.offset, 1)
//			xtextDocument.replace(issue.offset, 1, firstLetter.toUpperCase)
//		]
//	}

	@Fix(PetrinetValidator.TRANS_MISSING_IN)
	def addInArc(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add incoming arc', 'Add incoming PTArc to transition ' + issue.data.get(0), '.',
			new ISemanticModification() {
				override apply(EObject element, IModificationContext context) throws Exception {
					val places = (element.eContainer as Petrinet).places
					val arcs = (element.eContainer as Petrinet).arcs
					val ptarc = PetrinetFactory.eINSTANCE.createPTArc()
					ptarc.name = 'newArc'
					var suffix = 1
					while(arcs.exists(a | a.name.equals(ptarc.name))) {
						ptarc.name = ptarc.name + suffix
						suffix++
					}
					ptarc.weight = 1
					ptarc.source = places.get(0)
					ptarc.source.out.add(ptarc)
					ptarc.target = element as Transition
					arcs.add(ptarc)
					(element as Transition).in.add(ptarc)	
				}				
			}
		)
	}	
	
	@Fix(PetrinetValidator.TRANS_MISSING_OUT)
	def addOutArc(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add outgoing arc', 'Add outgoing PTArc to transition ' + issue.data.get(0), '.',
			new ISemanticModification() {
				override apply(EObject element, IModificationContext context) throws Exception {
					val places = (element.eContainer as Petrinet).places
					val arcs = (element.eContainer as Petrinet).arcs
					val tparc = PetrinetFactory.eINSTANCE.createTPArc()
					tparc.name = 'newArc'
					var suffix = 1
					while(arcs.exists(a | a.name.equals(tparc.name))) {
						tparc.name = tparc.name + suffix
						suffix++
					}
					tparc.weight = 1
					tparc.source = element as Transition
					tparc.target = places.get(0)
					tparc.target.in.add(tparc)
					arcs.add(tparc)
					(element as Transition).out.add(tparc)	
				}				
			}
		)
	}	
	
	@Fix(PetrinetValidator.DUPLICATE_EDGES)
	def deleteDuplicates(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove duplicate edges', 'Remove all edges which are duplicates of ' + issue.data.get(0), '.',
			new ISemanticModification() {
				override apply(EObject element, IModificationContext context) throws Exception {
					val petrinet = element.eContainer as Petrinet
					if (element instanceof PTArc) {
						val PTArc ptarc = element as PTArc
						if (ptarc.source !== null && ptarc.target !== null) {
							duplicates = petrinet.arcs.filter [ a |
								a !== ptarc
								&& a instanceof PTArc 
								&& (a as PTArc).source == ptarc.source 
								&& (a as PTArc).target == ptarc.target
							].toList				
						}
						ptarc.source.out.removeAll(duplicates);
						ptarc.target.in.removeAll(duplicates);
					}

					if (element instanceof TPArc) {
						val TPArc tparc = element as TPArc
						if (tparc.source !== null && tparc.target !== null) {
							duplicates = petrinet.arcs.filter [ a |
								a !== tparc
								&& a instanceof TPArc
								&& (a as TPArc).source == tparc.source 
								&& (a as TPArc).target == tparc.target
							].toList
						}
						tparc.source.out.removeAll(duplicates);
						tparc.target.in.removeAll(duplicates);
					}					
					petrinet.arcs.removeAll(duplicates);
				}				
			}
		)
	}
	
	@Fix(PetrinetValidator.ARC_REFERENCE_MISSING)
	def addReferences(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add references', 'Add necessary references to ' + issue.data.get(0), '.',
			new ISemanticModification() {				
				override apply(EObject element, IModificationContext context) throws Exception {
					if (element instanceof PTArc) {
						val ptarc = element as PTArc
						if (!ptarc.source.out.contains(ptarc)) {
							ptarc.source.out.add(ptarc)
						}
						if (!ptarc.target.in.contains(ptarc)) {
							ptarc.target.in.add(ptarc)
						}
					} 
					
					if (element instanceof TPArc) {
						val tparc = element as TPArc
						if (!tparc.source.out.contains(tparc)) {
							tparc.source.out.add(tparc)
						}
						if (!tparc.target.in.contains(tparc)) {
							tparc.target.in.add(tparc)
						}
					} 
				}				
			}
		)
	}
}
